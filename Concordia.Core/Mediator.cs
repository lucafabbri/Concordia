// <auto-generated/>
using Concordia.Contracts;
using Microsoft.Extensions.DependencyInjection;
using System.Reflection;

namespace Concordia;

/// <summary>
/// Implements the mediator pattern, providing a central point for dispatching requests and publishing notifications.
/// </summary>
public class Mediator : IMediator, ISender
{
    private readonly IServiceProvider _serviceProvider;

    /// <summary>
    /// Initializes a new instance of the <see cref="Mediator"/> class.
    /// </summary>
    /// <param name="serviceProvider">The service provider used to resolve dependencies.</param>
    /// <exception cref="ArgumentNullException">Thrown if the <paramref name="serviceProvider"/> is null.</exception>
    public Mediator(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
    }

    /// <summary>
    /// Sends a request to a single handler and returns a response.
    /// </summary>
    /// <typeparam name="TResponse">The type of the response.</typeparam>
    /// <param name="request">The request to send.</param>
    /// <param name="cancellationToken">A cancellation token to cancel the operation.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the response.</returns>
    /// <exception cref="ArgumentNullException">Thrown if the <paramref name="request"/> is null.</exception>
    /// <exception cref="InvalidOperationException">Thrown if no handler is found for the request or if a pre/post-processor or handler does not implement the expected method.</exception>
    public async Task<TResponse> Send<TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken = default)
    {
        if (request == null) throw new ArgumentNullException(nameof(request));

        var requestType = request.GetType();
        var responseType = typeof(TResponse);

        // 1. Resolve and execute Pre-Processors
        var preProcessorInterfaces = typeof(IRequestPreProcessor<>).MakeGenericType(requestType);
        var preProcessors = _serviceProvider.GetServices(preProcessorInterfaces).ToList(); // GetServices returns IEnumerable<object>

        foreach (var preProcessor in preProcessors)
        {
            var processMethod = preProcessor.GetType().GetMethod(
                "Process",
                BindingFlags.Public | BindingFlags.Instance,
                null,
                new Type[] { requestType, typeof(CancellationToken) },
                null
            );
            if (processMethod == null)
            {
                throw new InvalidOperationException($"Pre-processor {preProcessor.GetType().Name} does not implement the expected Process method for request type {requestType.Name}.");
            }
            await (Task)processMethod.Invoke(preProcessor, new object[] { request, cancellationToken });
        }

        // 2. Resolve the main Request Handler
        var handlerType = typeof(IRequestHandler<,>).MakeGenericType(requestType, responseType);
        var handler = _serviceProvider.GetService(handlerType);

        if (handler == null)
        {
            throw new InvalidOperationException($"No handler found for request of type {requestType.Name} returning {responseType.Name}.");
        }

        // 3. Resolve and chain Pipeline Behaviors
        var pipelineBehaviorInterfaces = typeof(IPipelineBehavior<,>).MakeGenericType(requestType, responseType);
        var pipelineBehaviors = _serviceProvider.GetServices(pipelineBehaviorInterfaces).ToList();

        // The 'next' delegate starts by invoking the actual handler
        RequestHandlerDelegate<TResponse> next = async () =>
        {
            var handleMethod = handler.GetType().GetMethod(
                "Handle",
                BindingFlags.Public | BindingFlags.Instance,
                null,
                new Type[] { requestType, typeof(CancellationToken) },
                null
            );
            if (handleMethod == null)
            {
                throw new InvalidOperationException($"Handler {handler.GetType().Name} does not implement the expected Handle method for request type {requestType.Name}.");
            }
            return await (Task<TResponse>)handleMethod.Invoke(handler, new object[] { request, cancellationToken });
        };

        // Chain behaviors in reverse order of resolution (or registration)
        // The last registered behavior should wrap the handler directly
        for (int i = pipelineBehaviors.Count - 1; i >= 0; i--)
        {
            var currentBehavior = pipelineBehaviors[i];
            var previousNext = next; // Capture current 'next' for the closure

            next = async () =>
            {
                var behaviorHandleMethod = currentBehavior.GetType().GetMethod(
                    "Handle",
                    BindingFlags.Public | BindingFlags.Instance,
                    null,
                    new Type[] { requestType, typeof(RequestHandlerDelegate<TResponse>), typeof(CancellationToken) },
                    null
                );
                if (behaviorHandleMethod == null)
                {
                    throw new InvalidOperationException($"Pipeline behavior {currentBehavior.GetType().Name} does not implement the expected Handle method for request type {requestType.Name}.");
                }
                return await (Task<TResponse>)behaviorHandleMethod.Invoke(currentBehavior, new object[] { request, previousNext, cancellationToken });
            };
        }

        // Execute the chained pipeline
        TResponse response = await next();

        // 4. Resolve and execute Post-Processors
        var postProcessorInterfaces = typeof(IRequestPostProcessor<,>).MakeGenericType(requestType, responseType);
        var postProcessors = _serviceProvider.GetServices(postProcessorInterfaces).ToList();

        foreach (var postProcessor in postProcessors)
        {
            var processMethod = postProcessor.GetType().GetMethod(
                "Process",
                BindingFlags.Public | BindingFlags.Instance,
                null,
                new Type[] { requestType, responseType, typeof(CancellationToken) },
                null
            );
            if (processMethod == null)
            {
                throw new InvalidOperationException($"Post-processor {postProcessor.GetType().Name} does not implement the expected Process method for request type {requestType.Name} and response type {responseType.Name}.");
            }
            await (Task)processMethod.Invoke(postProcessor, new object[] { request, response, cancellationToken });
        }

        return response;
    }

    /// <summary>
    /// Sends a request to a single handler.
    /// </summary>
    /// <param name="request">The request to send.</param>
    /// <param name="cancellationToken">A cancellation token to cancel the operation.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    /// <exception cref="ArgumentNullException">Thrown if the <paramref name="request"/> is null.</exception>
    /// <exception cref="InvalidOperationException">Thrown if no handler is found for the request or if a pre-processor or handler does not implement the expected method.</exception>
    public async Task Send(IRequest request, CancellationToken cancellationToken = default)
    {
        if (request == null) throw new ArgumentNullException(nameof(request));

        var requestType = request.GetType();

        // 1. Resolve and execute Pre-Processors
        var preProcessorInterfaces = typeof(IRequestPreProcessor<>).MakeGenericType(requestType);
        var preProcessors = _serviceProvider.GetServices(preProcessorInterfaces).ToList();
        foreach (var preProcessor in preProcessors)
        {
            var processMethod = preProcessor.GetType().GetMethod(
                "Process",
                BindingFlags.Public | BindingFlags.Instance,
                null,
                new Type[] { requestType, typeof(CancellationToken) },
                null
            );
            if (processMethod == null)
            {
                throw new InvalidOperationException($"Pre-processor {preProcessor.GetType().Name} does not implement the expected Process method for request type {requestType.Name}.");
            }
            await (Task)processMethod.Invoke(preProcessor, new object[] { request, cancellationToken });
        }

        // 2. Resolve the main Request Handler
        var handlerType = typeof(IRequestHandler<>).MakeGenericType(requestType);
        var handler = _serviceProvider.GetService(handlerType);

        if (handler == null)
        {
            throw new InvalidOperationException($"No handler found for request of type {requestType.Name}.");
        }

        // Execute the handler
        var handleMethod = handler.GetType().GetMethod(
            "Handle",
            BindingFlags.Public | BindingFlags.Instance,
            null,
            new Type[] { requestType, typeof(CancellationToken) },
            null
        );
        if (handleMethod == null)
        {
            throw new InvalidOperationException($"Handler {handler.GetType().Name} does not implement the expected Handle method for request type {requestType.Name}.");
        }
        await (Task)handleMethod.Invoke(handler, new object[] { request, cancellationToken });

        // 3. Resolve and execute Post-Processors (for IRequest, response is void/Task.CompletedTask)
        // Note: IRequestPostProcessor<TRequest, TResponse> expects a TResponse.
        // If post-processors are needed for IRequest, a separate IRequestPostProcessor<TRequest> interface
        // or a specific handling for 'void' responses would be required.
        // For now, we'll skip post-processors for IRequest unless explicitly defined for it.
        // If a generic IRequestPostProcessor<TRequest, TResponse> is registered for a TRequest (where TResponse is object/Unit),
        // it will be resolved by the first Send method.
    }

    /// <summary>
    /// Publishes a notification to all registered handlers.
    /// </summary>
    /// <param name="notification">The notification to publish.</param>
    /// <param name="cancellationToken">A cancellation token to cancel the operation.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    /// <exception cref="ArgumentNullException">Thrown if the <paramref name="notification"/> is null.</exception>
    /// <exception cref="InvalidOperationException">Thrown if no <see cref="INotificationPublisher"/> is registered or if a notification handler does not implement the expected method.</exception>
    public async Task Publish(INotification notification, CancellationToken cancellationToken = default)
    {
        if (notification == null) throw new ArgumentNullException(nameof(notification));

        // Resolve INotificationPublisher internally from IServiceProvider
        var notificationPublisher = _serviceProvider.GetService<INotificationPublisher>();
        if (notificationPublisher == null)
        {
            throw new InvalidOperationException("No INotificationPublisher is registered in the service provider.");
        }

        await notificationPublisher.Publish(
            _serviceProvider.GetServices(typeof(INotificationHandler<>).MakeGenericType(notification.GetType()))
                            .Select(handler => (Func<INotification, CancellationToken, Task>)((n, ct) =>
                            {
                                var handleMethod = handler.GetType().GetMethod(
                                    "Handle",
                                    BindingFlags.Public | BindingFlags.Instance,
                                    null,
                                    new Type[] { notification.GetType(), typeof(CancellationToken) },
                                    null
                                );
                                if (handleMethod == null)
                                {
                                    throw new InvalidOperationException($"Notification handler {handler.GetType().Name} does not implement the expected Handle method for notification type {notification.GetType().Name}.");
                                }
                                return (Task)handleMethod.Invoke(handler, new object[] { n, ct });
                            }))
                            .ToList(),
            notification,
            cancellationToken
        );
    }
}